import urwid
import io, sys
import queue
import threading

    
class CommandHistory:
    """A class to store command history.
    
    This class emulates the command history browsing behaviour of a 
    standard Linux terminal.
    
    Attributes:
        history:   
            A list of previously entered commands.
            Index 0 is filled with None to give :attr:`history` 
            and :attr:`temp_history` the same length.
    
        temp_history:
            The same as :attr:`history`, but includes the newest 
            command (the one that is currently being written) at 
            index 0.
            If any previously given commands are modified  
            (through :meth:`update_command`), the modified forms 
            are saved here, while :attr:`history` contains the 
            original forms.
    
        index:
            The index of the currently selected command.
            0 is the command currently being written; 1 is the 
            previous one etc.
    """
    
    def __init__(self):
        """Initialize :attr:`history` to ``[]``, 
        :attr:`temp_history` to ``[None]`` and 
        :attr:`index` to ``0``.
        """
        self.history = [None]
        self.temp_history = ['']
        self.index = 0
    
    def up(self):
        """Increase :attr:`index` by 1 (i.e. select a command that is 
        older than the current one).
        
        If the current command is the oldest one, nothing is done.
        """
        self.index += 1
        if self.index >= len(self.history):
            self.index = len(self.history) - 1
    
    def down(self):
        """Decrease :attr:`index` by 1 (i.e. select a command that is 
        younger than the current one).
        
        If the current command is the youngest one, nothing is done.
        """
        self.index -= 1
        if self.index < 0:
            self.index = 0
        
    def get_command(self):
        """Return the currently selected command as a string."""
        return self.temp_history[self.index]
    
    def update_command(self, string):
        """Change the currently selected command into *string*."""
        self.temp_history[self.index] = string
        
    def enter_command(self):
        """Enter the currently selected command.
        
        This saves the command into memory and  and resets 
        :attr:`index` to 0. If the command was created by modifying a 
        previous command, that command's history entry will be reset 
        into its original form. If multiple identical commands are 
        entered consecutively, only one is saved, and empty commands 
        are not saved at all. 
        """
        
        # The command that was entered:
        entered_cmd = self.temp_history[self.index]
        # The command before that:
        try:
            previous_cmd = self.temp_history[self.index + 1]
        except IndexError:
            previous_cmd = None
        
        # If a previous command was modified and the entered, changes 
        # to it in the command history are erased by copying the 
        # original form from *history*.
        if self.index > 0:
            self.temp_history[self.index] = self.history[self.index]
            
        # Save the entered command to the command history.
        # However, don't save consecutive duplicates or empty commands.
        # FIXME: duplikaatteja tulee välillä
        if entered_cmd != '' and entered_cmd != previous_cmd:
            self.history.insert(1, entered_cmd)
            self.temp_history.insert(1, entered_cmd)
        
        # Add a new command to be edited; initially this is empty.
        self.history[0] = ''
        
        # Reset *index*.
        self.index = 0

class Lines(urwid.WidgetWrap):
    
    def __init__(self):
        super().__init__(urwid.Text(''))
        
    def activate_edit(self, prompt):
        self._w = urwid.Edit(self.text + prompt)
        
    def deactivate_edit(self):
        self._w = urwid.Text(self.text + self.command)
        
    def edit_active(self):
        return isinstance(self._w, urwid.Edit)
        
    @property
    def text(self):
        if self.edit_active():
            return self._w.caption
        else:
            return self._w.text
            
    @text.setter
    def text(self, value):
        if self.edit_active():
            self._w.set_caption(value)
        else:
            self._w.set_text(value)
        
    @property
    def command(self):
        try:
            return self._w.edit_text
        except AttributeError:
            raise RuntimeError('*command* can only be accessed in edit mode')
            
    @command.setter
    def command(self, value):
        try:
            self._w.set_edit_text(value)
        except AttributeError:
            raise RuntimeError('*command* can only be accessed in edit mode')
            
    def move_cursor_to_end(self):
        try:
            self._w.set_edit_pos(len(self._w.edit_text))
        except AttributeError:
            pass
    
        
class Shell(urwid.WidgetWrap):
    """This widget provides a scrollable Linux terminal-like user 
    interface consisting of multiple :class:`CommandLine` objects.
    
    Like :class:`ListBox`, this is also a box widget, so its container 
    sets its height and width.
    
    Attributes:
        command_history: A :class:`CommandHistory` object that stores 
            the command history.
    """
        
    def __init__(self):
        """Initialize a new :class:`ScrollableLines` object.
        
        Args:
            process_command: 
                The method that should be used for processing the 
                commands given to the TUI. The method should accept a 
                string as an argument, perform whatever tasks the 
                command requests, and return any possible output as a 
                string. If the command produces no output, the method 
                should return ``None`` instead.
        """
        self.input_queue = queue.Queue()
        self.history = CommandHistory()
        self.lines = Lines()
        super().__init__(self.lines)
        
    def print_output(self, string, end='\n'):
        self.lines.text = self.lines.text + string + end
                                
    def ask_input(self, prompt):
        self.lines.activate_edit(prompt)
        # Block until input is defined
        input_str = self.input_queue.get()
        self.input_queue.task_done()
        self.lines.deactivate_edit()
        self.print_output('input')
        return input_str
            
    def history_up(self):
        """Scroll command history up one step."""
        try:
            # Save the current line to history.
            self.history.update_command(self.lines.command)
            # Move up one line in the history.
            self.history.up()
            # Load a new line from history.
            self.lines.command = self.history.get_command()
        except RuntimeError:
            pass
        self.lines.move_cursor_to_end()
        
    def history_down(self):
        """Scroll command history down one step."""
        try:
            self.history.update_command(self.lines.command)
            self.history.down()
            self.lines.command = self.history.get_command()
        except RuntimeError:
            pass
        self.lines.move_cursor_to_end()
        
    def enter(self):
        """Enter the text on the current line as a command."""
        
        # Save the command to history.
        try:
            self.history.update_command(self.lines.command)
        except RuntimeError:
            pass
        self.history.enter_command()
        
        # Process the command.
        self.input_queue.put(self.lines.command, block=False)
        self.print_output('enter')
        #output = self.process_command()
        # Print output if there is any.
        #if output is not None:
        #    self.print_output(output)
        
        # Deactivate the current command line and create a new one.
        #self.current_line.deactivate()
        #self.new_command_line()
        
    def keypress(self, size, key):
        """Handle key presses (up, down, enter)."""
        if key == 'enter':
            self.enter()
        elif key == 'up':
            self.history_up()
        elif key == 'down':
            self.history_down()
        elif key == 'x':
            self.print_output('test')
        else:
            return super().keypress(size, key)        

def get_input(lines):
    def line_input(prompt=''):
        return lines.ask_input(prompt)
    return line_input

def get_print(lines):
    def line_print(string):
        lines.print_output(string)
    return line_print
    
def script(input=input, print=print):
    print('This program returns the sum of given numbers')
    total = 0
    while True:
        x = input("Enter a number or 'q': ")
        if x == 'q':
            break
        try:
            total += int(x)
        except ValueError:
            pass
    print(f'Sum: {total}')

shell = Shell()
input_func = get_input(shell)
print_func = get_print(shell)
thread = threading.Thread(target=script, args=[input_func, print_func], 
                          daemon=True)
thread.start()

loop = urwid.MainLoop(urwid.Filler(shell, 'top'))
loop.run()