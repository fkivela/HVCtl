import urwid
import io, sys


class CommandLine(urwid.WidgetWrap):
    """A single editable line consisting of a prompt and a 
    user-inputted string.
    """
    
    prompt = '>> '
        
    def __init__(self):
        """Initialize a new CommandLine."""
        widget = urwid.Edit(self.prompt)
        # The widget needs to be wrapped inside another class, because 
        # its type must be changed while keeping the object the same.
        super().__init__(widget)
        # *widget* is saved by WidgetWrap as self._w
        
    def move_cursor_to_back(self):
        """Move the cursor to the end of the line."""
        try:
            self._w.set_edit_pos(len(self.text))
        except AttributeError:
            raise RuntimeError(
                "the cursor can't be moved after deactivation")
        
    @property
    def text(self):
        """Get or set the user-inputted string."""
        try:
            return self._w.edit_text
        except AttributeError:
            return self._w.text
        
    @text.setter
    def text(self, string):
        try:
            self._w.edit_text = string
        except AttributeError:
            raise RuntimeError(
                "self.text can't be set after deactivation")
        
    def deactivate(self):
        """Change the widget wrapped by *self* into a non-editable 
        text field.        
        """
        self._w = urwid.Text(self._w.caption + self._w.edit_text)
        
    def selectable(self):
        """Return True.
        
        :class:`CommandLine` objects are selectable even when 
        deactivated, in order to make scrolling them with 
        :class:`urwid.ListBox` ."""
        # If CommandLine objects weren't always selectable, scrolling 
        # a CommandLines object with a ListBox wouldn't allow the 
        # cursor to be scrolled off-screen.
        return True
    
    def keypress(self, size, key):
        """All selectable widgets must impolent this method.
        
        This implementation simply calls the :meth:`keypress` method 
        of the :class:`Edit` class, or does nothing, if *self* is 
        deactivated.
        """
        try:
            return self._w.keypress(size, key)
        except AttributeError:
            return None

    
class CommandHistory:
    """A class to store command history.
    
    This class emulates the command history browsing behaviour of a 
    standard Linux terminal.
    
    Attributes:
        history:   
            A list of previously entered commands.
            Index 0 is filled with None to give :attr:`history` 
            and :attr:`temp_history` the same length.
    
        temp_history:
            The same as :attr:`history`, but includes the newest 
            command (the one that is currently being written) at 
            index 0.
            If any previously given commands are modified  
            (through :meth:`update_command`), the modified forms 
            are saved here, while :attr:`history` contains the 
            original forms.
    
        index:
            The index of the currently selected command.
            0 is the command currently being written; 1 is the 
            previous one etc.
    """
    
    def __init__(self):
        """Initialize :attr:`history` to ``[]``, 
        :attr:`temp_history` to ``[None]`` and 
        :attr:`index` to ``0``.
        """
        self.history = [None]
        self.temp_history = ['']
        self.index = 0
    
    def up(self):
        """Increase :attr:`index` by 1 (i.e. select a command that is 
        older than the current one).
        
        If the current command is the oldest one, nothing is done.
        """
        self.index += 1
        if self.index >= len(self.history):
            self.index = len(self.history) - 1
    
    def down(self):
        """Decrease :attr:`index` by 1 (i.e. select a command that is 
        younger than the current one).
        
        If the current command is the youngest one, nothing is done.
        """
        self.index -= 1
        if self.index < 0:
            self.index = 0
        
    def get_command(self):
        """Return the currently selected command as a string."""
        return self.temp_history[self.index]
    
    def update_command(self, string):
        """Change the currently selected command into *string*."""
        self.temp_history[self.index] = string
        
    def enter_command(self):
        """Enter the currently selected command.
        
        This saves the command into memory and  and resets 
        :attr:`index` to 0. If the command was created by modifying a 
        previous command, that command's history entry will be reset 
        into its original form. If multiple identical commands are 
        entered consecutively, only one is saved, and empty commands 
        are not saved at all. 
        """
        
        # The command that was entered:
        entered_cmd = self.temp_history[self.index]
        # The command before that:
        try:
            previous_cmd = self.temp_history[self.index + 1]
        except IndexError:
            previous_cmd = None
        
        # If a previous command was modified and the entered, changes 
        # to it in the command history are erased by copying the 
        # original form from *history*.
        if self.index > 0:
            self.temp_history[self.index] = self.history[self.index]
            
        # Save the entered command to the command history.
        # However, don't save consecutive duplicates or empty commands.
        if entered_cmd != '' and entered_cmd != previous_cmd:
            self.history.insert(1, entered_cmd)
            self.temp_history.insert(1, entered_cmd)
        
        # Add a new command to be edited; initially this is empty.
        self.history[0] = ''
        
        # Reset *index*.
        self.index = 0

        
class Lines(urwid.WidgetWrap):
    """This widget provides a scrollable Linux terminal-like user 
    interface consisting of multiple :class:`CommandLine` objects.
    
    Like :class:`ListBox`, this is also a box widget, so its container 
    sets its height and width.
    
    Attributes:
        command_history: A :class:`CommandHistory` object that stores 
            the command history.
    """
        
    def __init__(self, process_command):
        """Initialize a new :class:`ScrollableLines` object.
        
        Args:
            process_command: 
                The method that should be used for processing the 
                commands given to the TUI. The method should accept a 
                string as an argument, perform whatever tasks the 
                command requests, and return any possible output as a 
                string. If the command produces no output, the method 
                should return ``None`` instead.
        """
        self.history = CommandHistory()
        self.process_command = process_command
        line = CommandLine()
        self.current_line = line
        widget = urwid.Pile([line])
        super().__init__(widget)
                        
    def new_command_line(self):
        """Add a new editable command line."""
        line = CommandLine()
        self._w.contents.append((line, ('pack', None)))
        self.current_line = line
        self._w.focus_position = len(self._w.contents) - 1
                
    def new_output_line(self, string):
        """Add a new non-editable output line."""
        line = urwid.Text(string)
        self._w.contents.append((line, ('pack', None)))
        
    def history_up(self):
        """Scroll command history up one step."""
        # Save the current line to history.
        self.history.update_command(self.current_line.text)
        # Move up one line in the history.
        self.history.up()
        # Load a new line from history.
        self.current_line.text = self.history.get_command()
        self.current_line.move_cursor_to_back()
        
    def history_down(self):
        """Scroll command history down one step."""
        self.history.update_command(self.current_line.text)
        self.history.down()
        self.current_line.text = self.history.get_command()
        self.current_line.move_cursor_to_back()
        
    def enter(self):
        """Enter the text on the current line as a command."""
        
        # Save the command to history.
        self.history.update_command(self.current_line.text)
        self.history.enter_command()
        
        # Process the command.
        output = self.process_command(self.current_line.text)
        # Print output if there is any.
        if output is not None:
            self.new_output_line(output)
        
        # Deactivate the current command line and create a new one.
        self.current_line.deactivate()
        self.new_command_line()
        
    def keypress(self, size, key):
        """Handle key presses (up, down, enter)."""
        if key == 'enter':
            self.enter()
        elif key == 'up':
            self.history_up()
        elif key == 'down':
            self.history_down()
        else:
            return super().keypress(size, key)
        
    @property
    def contents(self):
        """Return the widgets contained in *self* as a list.
        """
        return [widget for widget, options in self._w.contents]
        
    def n_rows(self, n_cols):
        """Return the total number of text rows in *self*.
        
        Args:
            n_cols (int): The number of colums used to display the 
                rows.
        """
        return sum([line.rows((n_cols,)) for line in self.contents])
        

class ScrollBar(urwid.WidgetWrap):
    """A widget that provides a vertical scroll bar.
    
    This is a box widget, so its container sets its height and width.
    
    Attributes:
        scroller char: The character used to draw the moving part of 
            the scroll bar.
        background_char: The character used to draw the other parts of 
            the scroll bar.
    """
        
    def __init__(self, position, lines, scroller_char='█', background_char='░'):
        """Initialize a new scrollbar.
        
        Args:
            scroller_char (single-character str): 
                The initial value for :attr:`scroller_char`. 
            background_char (single-character str): 
                The initial value for :attr:`background_char`.
        """
        self.lines = lines
        self.position = position
        self.scroller_char = scroller_char
        self.background_char = background_char
        self._position = 0
        self.current_size = (0, 0)        
        # A filler must be used to make self a box widget.
        widget = urwid.Filler(urwid.Text(''))
        super().__init__(widget)
        
    def update(self, size=None):
        """Update the string displayed by *self*."""
        
        if size:
            self.current_size = size
        else:
            size = self.current_size
            
        text = self._generate_text(size)
        self._w.original_widget.set_text(text)
        
    def render(self, size, *args, **kwargs):
        """Update and render *self.*"""
        # Calling *update* in *mouse_event* is not enough, because 
        # *self* must be updated at least once before showing 
        # the UI to the user.
        # *__init__* can't update, because it deosn't know *size*.
        self.current_size = size
        self.update()
        return super().render(size, *args, **kwargs)
    
#    def _generate_text(self, size):
#        """Generate the string displayed by *self.*
#        
#        Returns:
#            A list of strings, each corresponding to a text row.
#            The list has the same dimensions as *size*.
#        """
#        ncols, nrows = size
#        basic_col = ncols * self.background_char
#        scroller_col = ncols * self.scroller_char
#        position = self.position.position
#        scroller_i = round(position * (nrows - 1))  
#        
#        rows = [scroller_col if i == scroller_i else basic_col
#                for i in range(nrows)]
#        return rows
    
    
    
    def _generate_text(self, size):
        """Generate the string displayed by *self.*
        
        Returns:
            A list of strings, each corresponding to a text row.
            The list has the same dimensions as *size*.
        """
        rows_visible = self.lines.current_size[1]
        total_rows = self.lines.total_rows(self.lines.current_size)
        scroller_relative_size = rows_visible / total_rows
        if scroller_relative_size > 1:
            scroller_relative_size = 1
        
        ncols, nrows = size
        n_scroller_rows = round(nrows * scroller_relative_size)
        
        if n_scroller_rows < 1:
            n_scroller_rows = 1
            
        n_basic_rows = nrows - n_scroller_rows
        position = self.position.position
        n_basic_rows_above = round(position * n_basic_rows)
        n_basic_rows_below = n_basic_rows - n_basic_rows_above

        basic_row = ncols * self.background_char
        scroller_row = ncols * self.scroller_char
        
        rows = n_basic_rows_above * [basic_row] + n_scroller_rows * [scroller_row] + n_basic_rows_below * [basic_row]
        assert len(rows) == nrows
        
        #display.set_text(repr(rows))
        
        if n_scroller_rows < 1:
            raise ValueError(1)
        
        return rows
    
    def mouse_event(self, size, event, button, col, row, focus):
        """Handle mouse events.
        
        Mouse button 1 moves the scroller.
        """
        if button == 1:
            ncols, nrows = size
            position = row / (nrows - 1)
            self.position.set_position(self, position)
            self.update()
            
    def upon_position_change(self, old_value, new_value):
        self.update()


class Position:
    
    def __init__(self, listeners):
        self.listeners = listeners
        self._position = 0
        
    @property
    def position(self):
        return self._position
        
    def set_position(self, listener, new_value):
        if new_value < 0 or new_value > 1:
            raise ValueError(
                f'position should be between 0 and 1, not {new_value}')
        
        old_value = self.position
        self._position = new_value
        
        other_listeners = self.listeners ^ {listener}
        for L in other_listeners:
            L.upon_position_change(old_value, new_value)


class ScrollableLines(urwid.WidgetWrap):
    """A wrapper that adds scrolling functionality to the :class:`Lines` 
    class.
    """
        
    def __init__(self, process_command, position):
        """Initialize a new :class:`ScrollableLines` object.
        
        Args:
            process_command: 
                A method passed to the initializer of the 
                :class:`Lines` class.
            position:
                A Position object.
        """
        self.position = position
        self.current_size = (0, 0)
        self.lines = Lines(process_command)
        super().__init__(urwid.ListBox([self.lines]))
        

    def mouse_event(self, size, event, button, col, row, focus):
        """Handle mouse events."""
        
        # Mouse wheel up
        if button == 4:
            self.scroll_up(size)
        # Mouse wheel down
        elif button == 5:
            self.scroll_down(size)
        else:
            return super().mouse_event(size, event, button, col, row, focus)
        
    def keypress(self, *args, **kwargs):
        
        old_offset = self.offset(self.current_size)
        old_max_offset = self.max_offset(self.current_size)
        old_position = old_offset / old_max_offset if old_offset else 0
        
        ret = super().keypress(*args, **kwargs)
        self.update_position(old_position)
        return ret
        
    def set_offset(self, size, offset):      
#        display.set_text(str(offset))
        old_offset = self.offset(self.current_size)
        old_max_offset = self.max_offset(self.current_size)
        old_position = old_offset / old_max_offset if old_offset else 0
        
        self._w.change_focus(size, 0, -offset)
        self.update_position(old_position)
        
    def total_rows(self, size):
        #return self._w.body[0].rows(size)
        lines = self._w.body[0]
        assert isinstance(lines, Lines)
        n_cols = size[0]
        assert isinstance(n_cols, int)
        #display.set_text(str(lines.n_rows(n_cols)))
        return lines.n_rows(n_cols)
    
        
    def offset(self, size):
        widget_offset, widget_inset = self._w.get_focus_offset_inset(size)
        return widget_inset
        #if ret > self.max_offset(size):
        #    ret = self.max_offset(size)
    
    def max_offset(self, size):
        cols, visible_rows = size
        return max(self.total_rows(size) - visible_rows, 0)
        
    def scroll_down(self, size):
        new_offset = self.offset(size) + 1
        if new_offset > self.max_offset(size):
            new_offset = self.max_offset(size)
        
        self.set_offset(size, new_offset)
        #self.update_position()
        
    def scroll_up(self, size):
        new_offset = self.offset(size) - 1
        if new_offset < 0:
            new_offset = 0
        
        self.set_offset(size, new_offset)
        #self.update_position()

    def render(self, size, *args, **kwargs):
        """Update and render *self.*"""
        self.current_size = size
        return super().render(size, *args, **kwargs)
    
#    @property
#    def lines(self):
#        return self._w.body.contents[0]
    
    def update_position(self, old_position):
        offset = self.offset(self.current_size)
        max_offset = self.max_offset(self.current_size)
        new_position = offset / max_offset if offset else 0
        self.position.set_position(self, new_position)
        
        if old_position == 1 and new_position < 1:
            self._remove_focus_from_last_widget()
        elif new_position == 1:
            self._focus_to_last_widget()
    
    def upon_position_change(self, old_value, new_value):
        
        max_offset = self.max_offset(self.current_size)
        offset = round(new_value * max_offset)
        self.set_offset(self.current_size, offset)  

        if old_value == 1 and new_value < 1:
            self._remove_focus_from_last_widget()
        elif new_value == 1:
            self._focus_to_last_widget()
            
    def _focus_to_last_widget(self):
        n_widgets = len(self.lines.contents)
        self.lines._w.focus_position = n_widgets - 1
            
    def _remove_focus_from_last_widget(self):
        try:
            n_widgets = len(self.lines.contents)
            self.lines._w.focus_position = n_widgets - 2
        except IndexError:
            pass
        

class ScrollArrow(urwid.WidgetWrap):
    
    def __init__(self, direction, lines):
        self.lines = lines
        self.direction = direction
        symbol = {'up': '▲', 'down': '▼'}[direction] 
        widget = urwid.Filler(urwid.Text(symbol))
        super().__init__(widget)
        
    def mouse_event(self, size, event, button, col, row, focus):
        if button == 1:
            if self.direction == 'up':
                self.lines.scroll_up(self.lines.current_size)
            else:
                self.lines.scroll_down(self.lines.current_size)
                

class CommandLineInterface(urwid.WidgetWrap):
    
    def __init__(self, process_command):
        self.position = Position(set())
        self.lines = ScrollableLines(process_command, self.position)
        self.scrollbar = ScrollBar(self.position, self.lines)
        self.position.listeners = {self.lines, self.scrollbar}
        self.arrow_up = ScrollArrow('up', self.lines)
        self.arrow_down = ScrollArrow('down', self.lines)
        
        pile = urwid.Pile([(1, self.arrow_up), self.scrollbar, (1, self.arrow_down)])
        super().__init__(urwid.Columns([self.lines, (2, pile)]))




def execute_command(string):
    print(f'Command {string}')

def process_command(string):
    out = io.StringIO()
    old = sys.stdout
    sys.stdout = out
    execute_command(string)
    sys.stdout = old
    return out.getvalue()[:-1]

display = urwid.Text('Hello World!')
#shell = CommandLineInterface(lambda s: display.set_text(s))
shell = CommandLineInterface(process_command)

upper_half = urwid.Filler(display, 'top')
lower_half = shell
screen = urwid.Pile([upper_half, lower_half])

loop = urwid.MainLoop(screen)
loop.run()